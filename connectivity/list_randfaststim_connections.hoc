proc connStimCells(){ local i, ij, si, pci, cellind, runresult, gid	// Create cells and assign a GID to each cell
	basegid = 1
	cellind=celltypeOI		
	for pcitr(&i, &ij, &gid, 0, 0) { // use the pciter over all cells of this type
		if (pc.gid_exists(gid)) {  
			conDelay =  3
			basegid = 1
			for precellType=0, numSynTypesVec.size()-1 {
				synWeight = cellType[precellType].wgtConns.x[cellind]
				numSynTypes = numSynTypesVec.x[precellType]
				for randSynNumber=0,numSynTypes-1 {
					nc_append(basegid + randSynNumber, gid, precellType, randSynNumber, synWeight + (basegid + randSynNumber+1)*1000, conDelay)	// Make the connection  // the latter part is for tracing the big bug, used by exp2sid mech (it will take away this extra part)
				}
				basegid = basegid + numSynTypes
			}
		}
	} 
}
connStimCells()


distres = 5
objref postcellgids
speed = 1

objref highIndices
objref fconn, fsubst

objref conns2make

basegid = 1

objref gidmap //[ncell]
gidmap = new Matrix(ncell,numSynTypesVec.max()+1,2)

gidmap.setcol(0,0)
/*for n=1, numSynTypesVec.max()-1 {
	gidmap.setcol(n,-1)
}*/

/*for n=0,ncell-1 {
	gidmap[n] = new Vector(0)
}*/

strdef precellType_string, postcellType_string, memstr
proc makeConnections () {local precellType, distres, postcellType, precellStart, precellEnd, postcellStart, postcellEnd, i, j, r
	// Attempt to connect all cells of each pre and post type
	install_fastconn()

	j = celltypeOI

		if (cellType[j].is_art()==0) {	// ppstim cells are never the post synaptic cell in a connection, so exclude here
			postcellType_string = cellType[j].cellType_string	// Load cell type string used to grab connection-specific properties later
			numpost = 1 //cellType[j].numThisHost
			postcellgids = new Vector(numpost)
			highIndices = new Vector(numpost)
			postcellgids.x[0] = gidOI
			highIndices.x[0] = 1+RandomSeedsConn

			for i = 0, numCellTypes-1 {	
				//if (cellType[i].is_art()==0) {
				precellType_string =  cellType[i].cellType_string	// Load cell type string used to grab connection-specific properties later
				//print "precellType_string: ", precellType_string, " -> postcellType_string: ", postcellType_string
				cellType[i].numCons.x[j]=connectCells (i, j, precellType_string, postcellType_string)
				//}	
			}		
			
			cellType[j].LastHighIndex = 1+RandomSeedsConn	
			for r=0, numpost-1 {
				if (cellType[j].LastHighIndex<highIndices.x[r]) {
					cellType[j].LastHighIndex = highIndices.x[r]
				}
			}
		}

	if ((PrintTerminal>1)) {print "Host ", pc.id, " connected cells."}
}

	objref params, conns2make
	objref randnum, synRand
	func connectCells () {local r, syn, distance, counter, precellType, postcellType, j, randSynNumber, pre_zpos, post_zpos , pre_xpos, post_xpos, pre_ypos, post_ypos, numSynTypes localobj cell
		// Args: precellType, postcellType, precellType_string, postcellType_string
		 precellType = $1
		 postcellType = $2
		 counter=0
		synWeight = cellType[$1].wgtConns.x[$2]
		numSyns = cellType[$1].numSyns.x[$2]
		numConns = cellType[$1].numConns.x[$2]				

		if (PrintTerminal>2) {print "Host ", pc.id, " is connecting: ", $s3, "s to ", $s4, "s."}

		if (numConns != 0 && numpost !=0) {
			params = new Vector(27)
			if (cellType[postcellType].numCells>=pc.nhost) {
				connlength = numConns*int(cellType[postcellType].numCells/pc.nhost+1.5)+cellType[postcellType].numCells
			} else {
				connlength = numConns+cellType[postcellType].numCells
			}
			mylength = 1+connlength*6	
			
			if (mylength>1e9) {mylength=1e9}
			
			conns2make = new Vector(mylength)

			params.x[0]=cellType[precellType].cellStartGid //gmin -- start gid of pre cell type
			params.x[1]=cellType[precellType].cellEndGid //gmax -- end gid of pre cell type
			params.x[2]= numConns //nconv
			//params.x[2]= numConns/cellType[postcellType].numCells //nconv
			params.x[3]= cellType[postcellType].numCells // number of cells of the postsynaptic type (total)
			params.x[4]= numpost  // number of cells of the postsynaptic type with gids on this computer
			params.x[5]= cellType[precellType].dist.x[2]*4 // sqrt(LongitudinalLength^2 + LayerVector.sum()^2 + TransverseLength^2)
			//100 //maxd - the distance of the dimension for which the fit equation was designed (should add all three...), in um
						// this also confusing because, right now, the equation calculates the overall distance (through all dimensions).
						// If per dimension, should compare to distance in that dimension only
			params.x[6]= distres //5 //steps - resolution of the fit , in number of steps to take			
			params.x[7]= cellType[precellType].dist.x[0] //a in the Gaussian fit // 5, .001, 30
			params.x[8]= cellType[precellType].dist.x[1] //b in the Gaussian fit
			params.x[9]= cellType[precellType].dist.x[2] //c in the Gaussian fit
			params.x[10]= cellType[precellType].dentateXBins*1.0
			params.x[11]= cellType[precellType].dentateYBins*1.0
			params.x[12]= cellType[precellType].dentateZBins*1.0
			params.x[13]= cellType[precellType].dentateXBinSize
			params.x[14]= cellType[precellType].dentateYBinSize
			params.x[15]= cellType[precellType].dentateZBinSize
			addheight = 0
			if (cellType[precellType].layerflag>0) {addheight=LayerVector.sum(0,cellType[precellType].layerflag-1)}
			params.x[16]= addheight
			params.x[17]= cellType[postcellType].dentateXBins*1.0
			params.x[18]= cellType[postcellType].dentateYBins*1.0
			params.x[19]= cellType[postcellType].dentateZBins*1.0
			params.x[20]= cellType[postcellType].dentateXBinSize
			params.x[21]= cellType[postcellType].dentateYBinSize
			params.x[22]= cellType[postcellType].dentateZBinSize
			addheight = 0
			if (cellType[postcellType].layerflag>0) {addheight=LayerVector.sum(0,cellType[postcellType].layerflag-1)}
			params.x[23]= addheight
			params.x[24]= cellType[postcellType].cellStartGid
			params.x[25]= 1+RandomSeedsConn
			params.x[26]= connlength
			
			conns2make.fastconn(params, postcellgids, highIndices)	
			
			{pc.barrier()}
			sprint(memstr, "Defined %s to %s conns", $s3, $s4)
			zzz = mallinfo(zzz, memstr)
			for r=0, numpost-1 {
				highIndices.x[r] = int(conns2make.x[2+r]/1)
			}

			{pc.barrier}
			numSynTypes = 0

			for r=1+numpost, int(conns2make.x[0]/1)+numpost {		
				if (pc.gid_exists(0)) { // conns2make.x[r+1+connlength])
					cell = pc.gid2cell(0)
					numSynTypes = cell.pre_list.o(precellType).count()
					if (numSynTypes > 0) {
						ransynlist.object(0).r.discunif(0,numSynTypes-1)		// Create a uniform random INTEGER variable over the range specified (0 to # synapse types-1),
						for s=1,numSyns {
							randSynNumber = ransynlist.object(0).repick	// Randomly pick a synapse type from the available synapse types
							if (gidOI==conns2make.x[r+1]) {
								nc_append(0, 0, precellType, randSynNumber, synWeight + (0+1)*1000, conDelay)	// Make the connection  // the latter part is for tracing the big bug, used by exp2sid mech (it will take away this extra part)
							} else {						
								{gidmap.setval(conns2make.x[r+1],gidmap.getval(conns2make.x[r+1],0)+1, basegid + randSynNumber)}
								gidmap.setval(conns2make.x[r+1],0,gidmap.getval(conns2make.x[r+1],0)+1)
								// gidmap[conns2make.x[r+1]].append(basegid + randSynNumber)
							}
						}
						counter +=1
					}
				}
			}
		}
		basegid = basegid + numSynTypesVec.x[precellType]
		if (numSynTypesVec.x[precellType]==0) {basegid = basegid + 1}

		return counter
	}
makeConnections()								// Try making connections between every type of cell