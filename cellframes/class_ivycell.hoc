// Stole everything from the pvbasketcell, put it here
begintemplate ivycell
// public variables
public  pre_list, connect_pre, append_sections, is_art, is_connected, gid, randi
public soma, bcdendAP1, bcdendAP2, bcdendBAS1, bcdendBAS2
public all, adend, bdend, cdend, ddend
public x, y, z, position

// objects
objref syn, pre_list, templist

// external variables
external numCellTypes, cellType

// create the sections[nsegments]
// if nsegments (the number of segments in each section) is updated,
// you'll have to manually change the bounds on the for loops as well
create soma, bcdendAP1[4], bcdendAP2[4], bcdendBAS1[4], bcdendBAS2[4]

// set the initialization code, which is run whenever a new object
// of this class is instantiated
proc init() {
	gid = $1
	randi = $2
	// cell sections: soma, dendrites, axon
	append_sections() // append all sections to the section list
	connect_sections()// connect soma, dendrites, axon
	size_sections()	// set the size dimensions of each section
	set_nseg()		// set the number of segments in each section
	
	// subcellular mechanisms: channels, pumps, transporters
	insert_mechs()
	set_biophys()
	define_shape()

	pre_list = new List() // define a list for the presynaptic connections
	define_synapses()
}

objref all, adend, bdend, cdend, ddend // this is also defined later, in a fcn. which place should it be defined?
proc connect_sections() { local i
	connect bcdendAP1[0](0), soma(1)
	connect bcdendAP2[0](0), soma(1)
	connect bcdendBAS1[0](0), soma(0)
	connect bcdendBAS2[0](0), soma(0)
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendAP1[i](0), bcdendAP1[i-1](1)
	}
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendAP2[i](0), bcdendAP2[i-1](1)
	}
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendBAS1[i](0), bcdendBAS1[i-1](1)
	}
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendBAS2[i](0), bcdendBAS2[i-1](1)
	}
}

proc append_sections() { local i
	//objref all, adend, bdend, cdend, ddend // we shouldn't have to redefine... right?
	// Make a list for every section in the cell
	all = new SectionList()	
		soma all.append()
		for i=0, 3 {bcdendAP1 [i] all.append()}
		for i=0, 3 {bcdendAP2 [i] all.append()}
		for i=0, 3 {bcdendBAS1 [i] all.append()}
		for i=0, 3 {bcdendBAS2 [i] all.append()}

	// Make lists of dendrite sections that
	//  are all the same relative distance
	//  from the soma (useful when adding ion channels)
	// The code in this section will have to be customized
	//  depending on how detailed (and different) the sections
	//  are for each main dendrite
	adend  = new SectionList()	
		bcdendAP1 [0] adend.append()
		bcdendAP2 [0] adend.append()
		bcdendBAS1 [0] adend.append()
		bcdendBAS2 [0] adend.append()

	bdend  = new SectionList()
		bcdendAP1 [1] bdend.append()
		bcdendAP2 [1] bdend.append()
		bcdendBAS1 [1] bdend.append()
		bcdendBAS2 [1] bdend.append()

	cdend  = new SectionList()
		bcdendAP1 [2] cdend.append()
		bcdendAP2 [2] cdend.append()
		bcdendBAS1 [2] cdend.append()
		bcdendBAS2 [2] cdend.append()

	ddend  = new SectionList()
		bcdendAP1 [3] ddend.append()
		bcdendAP2 [3] ddend.append()
		bcdendBAS1 [3] ddend.append()
		bcdendBAS2 [3] ddend.append()
}

proc size_sections() { local i
	soma {L=20 diam=15}
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendAP1 [i] {L=75 diam=4-i}
	}	
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendAP2 [i] {L=75 diam=4-i}
	}	
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendBAS1 [i] {L=50 diam=4-i}
	}	
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendBAS2 [i] {L=50 diam=4-i}
	}
}

external lambda_f
proc set_nseg() {
  	forsec all { nseg = int((L/(0.1*lambda_f(100))+.9)/2)*2 + 1  }
}

proc insert_mechs() {
	gna = 0.15
	kdrf = 0.0065
	forsec all {
		insert iconc_Ca
			catau_iconc_Ca = 10
			caiinf_iconc_Ca = 5.e-6
		insert ch_KvA
			gkabar_ch_KvA=0.00015
		insert ch_CavN
			gmax_ch_CavN=0.0008   
		insert ch_CavL 
			gmax_ch_CavL=0.005
		insert ch_KCaS
			gskbar_ch_KCaS = 0.000002 // 0.00002
		insert ch_KvCaB
			gkbar_ch_KvCaB = 0.0002 // 0.002
	}

	soma {		
		insert ch_Nav
			gmax_ch_Nav = gna // 0.012*20  
			ena = 55 // newly added
		insert ch_leak
			g_ch_leak = 0.00018
		insert ch_Kdrfast
			gkfbar_ch_Kdrfast=kdrf  
	} 

	forsec adend {
		insert ch_Nav
			gmax_Nav= gna // 0.012  *20
			ena = 55 
		insert ch_leak
			g_ch_leak = 0.00018
		insert ch_Kdrfast
			gmax_ch_Kdrfast=kdrf
	}		
	forsec	bdend {
		insert ch_Nav
			gmax_Nav=gna  // *20
		insert ch_leak
			g_ch_leak = 0.00018
		insert ch_Kdrfast
			gmax_ch_Kdrfast=kdrf
	}
		
	forsec 	cdend {
		insert ch_Nav
			gmax_Nav=gna //  *20
		insert ch_leak
			g_ch_leak = 0.00018
		insert ch_Kdrfast
			gmax_ch_Kdrfast=kdrf
	}

	forsec	ddend {
		insert ch_Nav
			gmax_Nav=gna //  *20
		insert ch_leak
			g_ch_leak = 0.00018
		insert ch_Kdrfast
			gmax_ch_Kdrfast=kdrf
	}
}

proc set_biophys() {
	forsec all {
		Ra=100		// Ra = Axial resistivity in ohm-cm. Ra is a
					//  section variable that must be set for each
					//  section. Default is 35.4.
	
		cm=1.4		// capacitance in uF/cm^2. default = 1.0
	
		//ena = 55 
		ek=-90  
		//ekca=-90		// ek = reversal potential in mV. Associated with 
		//ekfa=-90		// ek = reversal potential in mV. Associated with 
		//ekls=-90		// ek = reversal potential in mV. Associated with 
		elca=130	
		e_ch_leak =-60

		cao_iconc_Ca=2
		}  // make catau slower70e-3 	cao=2 cai=50.e-6 
}

	proc connect_pre() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
			$o2.threshold = -10 //except for bcell to bcell, which is -10???

	}

	func is_art()  { return 0 }

proc position(){ local i
	forall {
		for i = 0, n3d()-1 {
			pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
		}
	}
	x = $1  y = $2  z = $3	
}

objref syn  
proc define_synapses() {


}
endtemplate ivycell
