begintemplate CellCategoryInfo
	public setCellTypeParams, setCellTypeDist
	public dist, cellType_string, cellStartGid, cellEndGid, numCells, updateGidRange, addPosVec, layerflag, CellList, addCell, numCons
	public setBins, dentateYBins, dentateXBins, dentateZBins, dentateYBinSize, dentateXBinSize, dentateZBinSize
	objref dist, cellpos, f1, CellList, numCons, this
	strdef cellType_string, tempString, cmd, strtomax 
		
	proc setCellTypeParams(){
		cellType_string = $s1
		cellStartGid = $2 //determine GID assignment start numbers for each cell type so that each cell can have a unique id #
		numCells = $3
		cellEndGid =  $2 + $3 -1
		layerflag = $4
		
		objref CellList[numCells]
	}

	proc setCellTypeDist(){
		f1 = new File()
		dist = new Vector(3)
		sprint(tempString,"./cells/dist_%s.hoc",cellType_string)
		f1.ropen(tempString)
		dist.scanf(f1)
		f1.close()
	}
	
	proc updateGidRange() {
		cellStartGid = $1
		cellEndGid = $1 + numCells -1
	}
	
	proc setBins() {local runresult, toohigh, numtomin // dentateXlength, dentateYlength, dentateZlength
		dentateZBins=int((numCells*($3)^2/($2*$1))^(1/3))			// Equivalent subdivisions of the dentate along the Z axis
		if (dentateZBins==0) {dentateZBins=1}
		dentateYBins=int(($2/$3)*(numCells*($3)^2/($2*$1))^(1/3))	// Equivalent subdivisions of the dentate along the Y axis
		if (dentateYBins==0) {dentateYBins=1}
		dentateXBins=int(($1/$3)*(numCells*($3)^2/($2*$1))^(1/3))	// Equivalent subdivisions of the dentate along the X axis
		if (dentateXBins==0) {dentateXBins=1}
		if ($3 >= $2 && $3 >= $1) {
			strtomax="dentateZBins"
			numtomin=dentateXBins*dentateYBins
		} else {
			if ($2 >= $3 && $2 >= $1) {
				strtomax="dentateYBins"
				numtomin=dentateXBins*dentateZBins
			} else {
				strtomax="dentateXBins"
				numtomin=dentateYBins*dentateZBins
			}
		}

		while (dentateXBins*dentateYBins*dentateZBins < numCells){
			sprint(cmd, "%s=%s+1",strtomax,strtomax)
			runresult=execute1(cmd, this) 		// This command was written as a string so
												//	the Bin dimension to increase doesn't have to be hard coded
		}

		toohigh=dentateXBins*dentateYBins*dentateZBins-numtomin
		while (toohigh >= numCells){
			sprint(cmd, "%s=%s-1",strtomax,strtomax)
			runresult=execute1(cmd, this) 		// This command was written as a string so
												//	the Bin dimension to increase doesn't have to be hard coded
			toohigh=dentateXBins*dentateYBins*dentateZBins-numtomin
		}

		dentateZBinSize = int($3/dentateZBins)	// Length of each bin (along Z dimension) in microns
		dentateYBinSize = int($2/dentateYBins)	// Length of each bin (along Y dimension) in microns
		dentateXBinSize = int($1/dentateXBins)	// Length of each bin (along X dimension) in microns
	}

endtemplate CellCategoryInfo
