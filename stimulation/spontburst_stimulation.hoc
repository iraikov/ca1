proc perfpathStims() { local i, reli, typei, jgid, celltype, counter, jstart, jend, jtot localobj cell, onstimobj, offstimobj		// Connect the perforant path cells to the model cells
	for celltype=1, numCellTypes-1 {
		if (strcmp(cellType[celltype].cellType_string,"pyramidalcell")==0) {	// Connect to some granule cells
			for pcitr(&reli, &typei, &jgid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
				if (pc.gid_exists(jgid)) {
					cell = pc.gid2cell(jgid)
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 2e-2, 3)  
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 2e-2, 3) 
					cellType[0].numCons.x[celltype] +=2
				}
			}
		}
		if (strcmp(cellType[celltype].cellType_string,"pvbasketcell")==0 or strcmp(cellType[celltype].cellType_string,"dgbasketcell")==0) {	// Connect to some basket cells
			for pcitr(&reli, &typei, &jgid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
				if (pc.gid_exists(jgid)) {
					cell = pc.gid2cell(jgid)
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 1e-2, 3) 
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 1, 1e-2, 3)  
					cellType[0].numCons.x[celltype] +=2
				}
			}	
		}
		if (strcmp(cellType[celltype].cellType_string,"axoaxoniccell")==0) {	// Connect to some basket cells
			for pcitr(&reli, &typei, &jgid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
				if (pc.gid_exists(jgid)) {
					cell = pc.gid2cell(jgid)
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 1e-2, 3) 
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 1e-2, 3)  
					cellType[0].numCons.x[celltype] +=2
				}
			}	
		}
		if (strcmp(cellType[celltype].cellType_string,"cckcell")==0) {	// Connect to some basket cells
			for pcitr(&reli, &typei, &jgid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
				if (pc.gid_exists(jgid)) {
					cell = pc.gid2cell(jgid)
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 1e-2, 3) 
					nc_appendo(jgid-cellType[0].cellEndGid-1+pc.nhost*2, cell, 0, 0, 1e-2, 3)  
					cellType[0].numCons.x[celltype] +=2
				}
			}	
		}
	}
}
	proc addstims() {local reli, typei, jgid localobj cell, onstimobj, offstimobj
		for pcitr(&reli, &typei, &jgid, cellType[0].cellStartGid+pc.nhost*2, cellType[0].cellEndGid) {
			if (pc.gid_exists(jgid)) {
				cell = pc.gid2cell(jgid)
				onstimobj = pc.gid2cell(pc.id) // what are the gids for these things?
				offstimobj = pc.gid2cell(pc.id+pc.nhost) // what are the gids for these things?
				set_ctrl_stims(onstimobj,offstimobj)
				add_on_off(jgid, onstimobj, offstimobj)
				cellType[0].numCons.x[0] +=2
			}
		}	
	}


	proc add_on_off() {localobj ns, ctrlsyn, offsyn	// arg 1: gid of the netstim to which the control on and off netstims must be attached
													// arg 2: object of the on NetStim
													// arg 3: object of the off NetStim
													
		ns = pc.gid2cell($1)

		ctrlsyn = new NetCon($o2, ns)
		ctrlsyn.weight = 1
		ctrlsyn.delay = 0
		nclist.append(ctrlsyn)


		offsyn = new NetCon($o3, ns)
		offsyn.weight = -1
		offsyn.delay = 0
		nclist.append(offsyn)
	}

	proc set_ctrl_stims() { // first argument is the on NetStim object, second is off
		$o1.interval = onint+offint
		$o1.number = 100
		$o1.start = 0
		$o1.noise = 0

		$o2.interval = onint+offint
		$o2.number = $o1.number
		$o2.start = onint
		$o2.noise = $o1.noise
	}
perfpathStims()
addstims()


