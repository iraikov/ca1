proc createCells(){ local i, ij, si, pci, cellind, runresult, gid	// Create cells and assign a GID to each cell
	cellind=celltypeOI				
	for pcitr(&i, &ij, &gid, cellType[cellind].cellStartGid, gidOI) {// use the pciter over all cells of this type
		if (pc.gid_exists(gid)) { 
			// sprint(cmd, "{cellType[%g].CellList[%g]=new %s(%g,%g)}", cellind, ij, cellType[cellind].technicalType, gid, i) //+cellType[cellind].cellStartGid) // why add the startgid to the gid? 
			sprint(cmd, "{cellType[%g].CellList[%g]=new %s(%g,%g)}", cellind, ij, celltype2use, gid, i) //+cellType[cellind].cellStartGid) // why add the startgid to the gid? 
			{runresult=execute(cmd)} //prints a zero!		// This command was written as a string so
											//	the cell object doesn't have to be hard coded

			cells.append(cellType[cellind].CellList[ij])	// Append each cell to cells list
			cellType[cellind].numThisHost = ij+1 // set number of cells of this type on this host (but add 1 b/c ij is zero based)

			ransynlist.append(new RandomStream(1+RandomSeedsConn, gid + 1*ncell)) // Create a new random number generator for each cell,
														//	with a unique stream. This will be used to determine
														//	what type of synapse is used in connections
														// lowindex = gid is used in the connection algorithm in the mod file
			ranstimlist.append(new RandomStream(1+RandomSeedsStim, gid + 2*ncell)) // Create a new random number generator for each cell, used by netstims for setting spont stim.

			cellType[cellind].CellList[ij].connect_pre(nil, nc)	// Create an empty connection for use by the spike detector
			pc.cell(gid, nc)									// Associate the cell with its gid and its spike generation location
			
			for si=0, cellType[cellind].CellList[ij].pre_list.count-1 {	// Iterate over each pre cell type's synapse list
				for j=0, cellType[cellind].CellList[ij].pre_list.o(si).count-1 {		// Iterate through each synapse in the list
					cellType[cellind].CellList[ij].pre_list.o(si).o(j).cid=gid			// Set the cell id for each synapse
																						//  Note: Parameters added to Syn2Gid mechanism
				}
			}

							
			addheight=0
			if (cellType[cellind].layerflag>0) {addheight=LayerVector.sum(0,cellType[cellind].layerflag-1)}

			xpos=get_x_pos(gid,cellType[cellind].cellStartGid,cellType[cellind].dentateXBins,cellType[cellind].dentateYBins*cellType[cellind].dentateZBins,cellType[cellind].dentateXBinSize)	// Algorithmically generate cell position
			ypos=get_y_pos(gid,cellType[cellind].cellStartGid,cellType[cellind].dentateYBins,cellType[cellind].dentateZBins,cellType[cellind].dentateYBinSize)	// Algorithmically generate cell position
			zpos=get_z_pos(gid,cellType[cellind].cellStartGid,cellType[cellind].dentateZBins,cellType[cellind].dentateZBinSize,addheight)	// Algorithmically generate cell position
			cellType[cellind].CellList[ij].position(xpos,ypos,zpos)									// Record cell position in cell object								
		}
	} 

	nc = nil // Then clear the reference to the netcon object, which should destroy the netcon (because all refs would have been removed)
	if  (PrintTerminal>1) {print "Host ", pc.id, " created cells."}
}
createCells()
