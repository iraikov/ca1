/************************************************************
'ca1' model code repository
Written by Ivan Raikov, ivan.g.raikov@gmail.com and Marianne
Bezaire, marianne.bezaire@gmail.com, www.mariannebezaire.com
In the lab of Ivan Soltesz, www.ivansolteszlab.org
Latest versions of this code are available online at:
ModelDB: 
Open Source Brain: http://www.opensourcebrain.org/projects/nc_ca1

Main code file: ../main.hoc
This file: Last updated on November 16, 2015

This file computes an approximation to the LFP generated by the
pyramidal cells in the network, based on the formula by Schomburg et
al., J Neurosci 2012.

The approximate LFP is calculated as the sum of current contributions
of all compartments, scaled by the distances to the recording
electrode and extracellular medium resistivity.  The time resolution
of the LFP calculation may be lower than that of the simulation by
setting lfp_dt in this file.
************************************************************/

objref lfplist, lfpklist
lfplist = new List()
lfpkmatrix = new Matrix()

func arcsin () { local x
    x = $1
    
    return atan2(x, sqrt(1.0 - x*x))
}

func npole_pos_lfp() { local avglfp, vlfp, celltype, pci, gid, i, j, ex, ey, ez, typei, MaxEDist localobj cell
 	// Calculate the average LFP of select pyramidal cells in the network,
	//  only including pyramidal cells whose somata are within MaxEDist
	//  microns of the (x,y,z) location passed into this function as
	//  arguments: $1 = x, $2 = y, $3 = z in microns
	
	MaxEDist = $1 // microns
        ex = $2
        ey = $3
        ez = $4
        
        
	sumcell = 0
	vlfp = 0 // Initialize the LFP currents variable
        
        for celltype=0, numCellTypes-1 { // Iterate over all cell types
	    if (strcmp(cellType[celltype].cellType_string, "pyramidalcell")==0) {	// Choosing pyramidal cells	
                
		for pcitr(&i, &typei, &gid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
		    cell = pc.gid2cell(gid)
		    
		    // Relative to the recording electrode position
		    if (sqrt((cell.x-ex)*(cell.x-ex) + (cell.y-ey)*(cell.y-ey) + (cell.z-ez)*(cell.z-ez))<MaxEDist) {
                        // Iterate over each compartment of the cell
                        j = 0
                        forsec cell.all { 
                            forall {
			        vlfp = vlfp + (i_membrane(0.5) * lfpkmatrix.x[i][j])
                                j = j + 1
                            }
                        }
		    }
		}
	    }      
        }
        
	// Ensure all processors have completed their calculation before proceeding.
	pc.barrier()
        
        avglfp = pc.allreduce(vlfp, 1)
        
        return avglfp
    }
    
// Distance from a point to a line in 3D
// The point is defined by x0, y0, z0
// The line is defined by starting point x1, y1, z1 and ending point x2, y2, z2
proc linedist () { local x0, x1, x2, y0, y1, y2, z0, z1, z2, la, lb, lc, s, a, r, h, abc localobj res
    
    res = $o1
    
    x0 = $2
    y0 = $3
    z0 = $4
    // line starting point
    x1 = $5
    y1 = $6
    z1 = $7
    // line ending point
    x2 = $8
    y2 = $9
    z2 = $10
    
    // Calculates the area of the triangle formed by the three points
    // using Heron's formula
    
    // Lengths of triangle sides
    la = sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0) + (z1-z0)*(z1-z0))
    lb = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1))
    lc = sqrt((x2-x0)*(x2-x0) + (y2-y0)*(y2-y0) + (z2-z0)*(z2-z0))
    
    // Semiperimeter of triangle
    s = (la + lb + lc) / 2
    
    // Area of triangle
    a = sqrt(s * (s - la) * (s - lb) * (s - lc))
    
    // Perpendicular distance from point to line
    r = (a*2) / lb
    
    // Angle between point and starting point of line
    abc = arcsin(r / la)
    
    // Longitudinal distance from point to starting point of line
    h = la * cos(abc)
    
    dist.x[0] = r
    dist.x[1] = h
}


proc sample_npole_lfp() { local i, j, r, h, s, avglfp, gid, celltype, ex, ey, ez localobj dists, vec, lst
    
    rho = 333.0 // extracellular resistivity, [ohm]
    
    
    ex = mypoint.x[0]
    ey = mypoint.x[1]
    ez = mypoint.x[3]
    
    // At t=0, calculate distances from recording electrode to all
    // compartments of all pyramidal cells, calculate scaling
    // coefficients for the LFP calculation, and save them in
    // lfpkmatrix.
    
    if (t == 0) {
        
        // Vector for storing longitudinal and perpendicular distances
        // between recording electrode and compartments
        dists = new Vector(2)
        
        for celltype=0, numCellTypes-1 { // Iterate over all cell types
	    if (strcmp(cellType[celltype].cellType_string, "pyramidalcell")==0) {	// Choosing pyramidal cells	
                
		for pcitr(&i, &typei, &gid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
		    cell = pc.gid2cell(gid)
		    
		    // Relative to the recording electrode position
		    if (sqrt((cell.x-ex)*(cell.x-ex) + (cell.y-ey)*(cell.y-ey) + (cell.z-ez)*(cell.z-ez))<MaxEDist) {
                        // Iterate over each compartment of the cell
                        j = 0
                        forsec cell.all { 
                            forall {
                                // L is compartment length 
                                // r is the perpendicular distance from the electrode to a line through the compartment
                                // h is longitudinal distance along this line from the electrode to one end of the compartment
                                // s = l + h is longitudinal distance to the other end of the compartment
                                linedist (dists,ex,ey,ez,x3d(0),y3d(0),z3d(0),x3d(n3d()-1),y3d(n3d()-1),z3d(n3d()-1))
                                r = dists.x[0]
                                h = dists.x[1]
                                s = L + h
			        lfpkmatrix.x[i][j] = (rho / (4 * PI * L)) * abs(log((sqrt(h*h + r*r) - h) / (sqrt(s*s + r*r) - s)))
                                j = j + 1
                            }
                        }
		    }
		}
	    }      
        }
    }

    
    // Execute this code regularly throughout the simulation
    //  to add datapoints to all the LFP recordings (average
    //  and per-cell).
    
    // Compute LFP across a subset of cells within a certain distance from the recording electrode:
    avglfp = npole_pos_lfp(ex,ey,ez) // x, y, z position of electrode in microns
    
    if (pc.id == 0) {
        
        vec = new Vector()
        // For this time step, create a vector with entries of time and average LFP
	vec.append(t, avglfp)			
        // Append the vector for this time step to the list
	lfplist.append(vec.c)			
    }
    
    
    // Add another event to the event queue, to 
    // execute sample_npole_lfp again, lfp_dt ms from now
    cvode.event(t + lfp_dt, "sample_npole_lfp()")		
}