/************************************************************
'ca1' model code repository
Written by Marianne Bezaire, marianne.bezaire@gmail.com, www.mariannebezaire.com
In the lab of Ivan Soltesz, www.ivansolteszlab.org
Published and latest versions of this code are available online at:
ModelDB: 
Open Source Brain: http://www.opensourcebrain.org/projects/nc_ca1

This file defines two procedures related to spontaneous stimulation:
1. connectStims: this is used when each cell needs to have its own,
   unique excitatory spike train input. This procedure connects
   a specific artificial cell to each real cell of the model, so that
   each real cell has its own independent input. When this procedure
   is used, then the artificial cells should NOT be connected to the
   real cells within the connectivity algorithm. If the connectivity
   algorithm is used instead, the difference is that any particular
   artificial cell could be connected to 0, 1, or multiple real cells
   in lines with whatever positioning and axonal distribution properties
   have been specified. This is a good alternative for when the
   artificial cells are meant to mimic real inputs to a network.
2. setNoise: this procedure sets the properties of the random number
   generators that are then associated to the noise functionality of
   the artificial cells. Each artificial cell has its own, unique
   random stream that is associated to its noise algorithm. The noise
   algorithm then draws from that random number stream to determine
   the interspike intervals that define the spike train pattern of the cell.
************************************************************/

// The connectStims procedure connects a specific artificial cell to
// each real cell of the model, and it does this for each artificial
// cell type. It expects there to be enough artificial cells of each
// type that a unique artificial cell can be connected with each real
// cell of the model. The specific artificial cell that is connected
// to each real cell has a gid that is related to the gid of the real
// cell.

proc connectStims() { local wgt, reli, typei, jgid, postcelltype, precelltype localobj cell
    for precelltype=0, numCellTypes-1 {	// For each potential presynaptic cell type
	if (cellType[precelltype].is_art==1) {	// If the cell is an artificial cell type
	    for postcelltype=0, numCellTypes-1 {	// For each potential postsynaptic cell type
		if (cellType[postcelltype].is_art==0) {	// If the cell is a real cell type
		    wgt = cellType[precelltype].wgtConns.x[postcelltype]	// Check the weight specified for this connection
		    if (wgt > 0) {											//  and if stronger than 0, make the connections
			
			// For each cell of type postsynaptic cell type owned by this processor
			for pcitr(&reli, &typei, &jgid, cellType[postcelltype].cellStartGid, cellType[postcelltype].cellEndGid) {
			    if (pc.gid_exists(jgid)) {
				cell = pc.gid2cell(jgid)	// Create a reference to the postsynaptic cell
                                
				if (cell.pre_list.o(precelltype).count()>0) {	// If potential synapses have been defined for this connection type
				    
				    // Make a single synapse connection from a specific artificial cell to a specific real cell, 
				    //  where the cells that are connected are related by their gids.
				    nc_appendo(jgid-cellType[postcelltype].cellEndGid-1+cellType[precelltype].cellStartGid, cell, precelltype, 0, wgt, 3)
				    cellType[precelltype].numCons.x[postcelltype] +=1	// Increment the connection counter
				}
			    }
			}
		    }
		}
	    }
	}
    }
}

if (MakeArtConns==0) {	// Only make connections from artificial cells if they 
    connectStims()      //  have not been connected at another time (ie, in the
}		//  connectivity algorithm)

proc setVecStim() {local sendpos, celltype_idx, rank_idx, rank_startgid, startgid, endgid, pop_size, gid_idx, gid_size localobj f, vindex, vspiketimes, vsizes, vcounts, vrecvcounts, vsendcounts, vsendcounts1, vgidspikes, vcellspikes, vsendbuf, cell strdef vecstim_index_filename, vecstim_filename
    
    vecstim_index_filename=$s1
    vecstim_filename=$s2
    
    celltype_idx=-1
    for celltype=0, numCellTypes-1 {

        vindex      = new Vector()
        vspiketimes = new Vector()
        vsizes      = new Vector()
        vsendbuf    = new Vector()
        vsendcounts1 = new Vector(pc.nhost)
        vsendcounts = new Vector(pc.nhost)
        vrecvcounts = new Vector(pc.nhost)
        vcounts     = new Vector()
        
        if (strcmp(cellType[celltype].technicalType, "ppvec")==0) {
	    celltype_idx = celltype 
        }
        
        if (celltype_idx > -1) {
            
            startgid = cellType[celltype_idx].cellStartGid
            endgid = cellType[celltype_idx].cellEndGid
            pop_size = endgid - startgid
            
            
            if (pc.id == 0) {
                
                f = new File ()
                
                status = f.ropen (vecstim_index_filename)
                vindex.vread(f)
                f.close()
                
                status = f.ropen (vecstim_filename)
                vspiketimes.vread(f)
                f.close()
                
                vsizes.resize(vindex.size())
                for (i=0; i < vindex.size()-1; i+=1) {
                    vsizes.x[i] = vindex.x[i+1] - vindex.x[i]
                }
                vsizes.x[vindex.size()-1] = vindex.size() - vindex.x[vindex.size()-1]
                
                vcounts.resize(pc.nhost)
                for (rank_idx=0; rank_idx < pc.nhost; rank_idx+=1) {
                    rank_startgid = startgid + rank_idx
                    for (gid=rank_startgid; gid <= endgid; gid += pc.nhost) {
                        gid_idx   = vindex.x[gid-startgid]
                        gid_size  = vsizes.x[gid-startgid]
                        vsendbuf.append(gid)
                        vsendbuf.append(gid_size)
                        vgidspikes = new Vector(gid_size)
                        vgidspikes.copy(vspiketimes, 0, gid_idx, gid_idx+gid_size-1)
                        vsendbuf.append(vgidspikes)
                        vcounts.x[rank_idx] += gid_size+2
                        vsendcounts.x[rank_idx] += gid_size+2
                    }
                    vsendcounts1.x[rank_idx] = 1
                }
            }
            
            // send out the number of spike entries each rank is going to receive
            pc.alltoall(vcounts, vsendcounts1, vrecvcounts)
            
            recvsize = 0
            for (rank_idx=0; rank_idx < pc.nhost-1; rank_idx+=1) {
                recvsize += vrecvcounts.x[rank_idx]
            }
            vspiketimes.resize(recvsize)
            
            // send out the spike vectors (only rank 0 sends data)
            pc.alltoall(vsendbuf, vsendcounts, vspiketimes)
            
            recvpos = 0
            while (recvpos < vspiketimes.size()) {
                
                gid = vspiketimes.x[recvpos]
                recvpos += 1
                gid_size = vspiketimes.x[recvpos]
                recvpos += 1
                vcellspikes = new Vector()
		if (gid_size > 0) {
		   vcellspikes.copy(vspiketimes, 0, recvpos, recvpos+gid_size-1)
                }
                recvpos += gid_size
                cell = pc.gid2cell(gid)
                cell.play(vcellspikes)
            }
        }
        
    }
}

setVecStim(VecStimIndexFileName,VecStimFileName)
