/************************************************************
For even more information, consult ModelDoc.pdf
************************************************************/

loadstart = startsw()					// record the start time of the set up
/***********************************************************************************************
I.  LOAD LIBRARIES
***********************************************************************************************/
{load_file("nrngui.hoc")}				// Standard definitions - NEURON library file
{load_file("netparmpi.hoc")}			// Contains the template that defines the properties of the
										// 	ParallelNetManager class
{load_file("./setupfiles/ranstream.hoc")}			// Defines a RandomStream class used to produce random numbers
										// 	for the cell noise
{load_file("./setupfiles/CellCategoryInfo.hoc")}		// Defines a CellCategoryInfo class used to store
										// 	celltype-specific parameters
{load_file("./setupfiles/defaultvar.hoc")} // proc definition for default_var procedure
{load_file("./setupfiles/parameters.hoc")}			// Loads in operational and model parameters that can be changed at command line
{load_file("./setupfiles/set_other_parameters.hoc")}			// Loads in operational and model parameters that can't be changed at command line

/***********************************************************************************************
II. SET MODEL SIZE, CELL DEFINITIONS
***********************************************************************************************/
{load_file("./setupfiles/load_cell_category_info.hoc")}			// 

strdef tempFileStr						// Define string reference for the names of the cell template files
proc loadFewCells(){local i		// Define one template for each cell type in cells2include, plus perforant path cell(s)
	totalCells = -1						// Initialize totalCells so we can add to it iteratively in the for loop
	ncell = 0
	for i=0, numCellTypes-1 {
		if (strcmp(cellType[i].cellType_string,"ppstim")==0 || strcmp(cellType[i].cellType_string,"pvbasketcell")==0 || strcmp(cellType[i].cellType_string,"pyramidalcell")==0) {
			sprint(tempFileStr,"./cells/class_%s.hoc",cellType[i].cellType_string)
			load_file(tempFileStr)			// Load the cell type's class template
			cellType[i].numCells = 1
			cellType[i].updateGidRange(ncell)	// Update the gid ranges for each cell type
			totalCells = totalCells + 1
			ncell = ncell + 1
		} else {
			cellType[i].numCells = 0
		}
	}
	random_stream_offset_= (totalCells*2+2)	// How far down the stream to start the next stream section -
}	
loadFewCells()

// don't care about the cell positions or bins

/***********************************************************************************************
III.SET UP PARALLEL CAPABILITY AND WRITE OUT RUN RECEIPT
***********************************************************************************************/
objref pnm, pc, nc, nil
proc parallelizer() {
	pnm = new ParallelNetManager(ncell)	// Set up a parallel net manager for all the cells
	pc = pnm.pc
	pnm.round_robin()					// Incorporate all processors - cells 0 through ncell-1
										//	are distributed throughout the hosts
										//	(cell 0 goes to host 0, cell 1 to host 1, etc)
}
parallelizer()

iterator pcitr() {local i2, startgid	// Create iterator for use as a standard 'for' loop throughout given # cells
// usage:
// for pcitr(&i, &gid, it_start, it_end) {do stuff}	// it_start and it_end let you define range over which to iterate
	i1 = 0
	numcycles = int($3/pc.nhost)
	extra = $3%pc.nhost
	addcycle=0
	if (extra>pc.id) {addcycle=1}
	startgid=(numcycles+addcycle)*pc.nhost+pc.id
	if (startgid<=$4) {
		for (i2=startgid; i2 <= $4; i2 += pc.nhost) {	// Just iterate through the cells on this host
														//	(this works because of the roundrobin call made earlier)
				$&1 = i1
				$&2 = i2
				iterator_statement
				i1 += 1
		}
	}
}

{load_file("./setupfiles/save_run_info.hoc")}

loadtime = startsw() - loadstart		// Calculate the set up time (now - recorded start time) in seconds
if (pc.id == 0) {printf("\nTIME HOST 0: %g seconds (set up)\n************\n", loadtime)}
createstart = startsw()					// Record the start time of the cell creation
/***********************************************************************************************
IV. CREATE, AND UNIQUELY ID CELLS
***********************************************************************************************/
objref cells, ranconlist, ransynlist
cells = new List()						
ranconlist = new List()
ransynlist = new List()

{load_file("./setupfiles/create_cells.hoc")}		// Creates the cells on their assigned host and sets their positions

createtime = startsw() - createstart	// Calculate time taken to create the cells
if (pc.id == 0) {printf("\nTIME HOST 0: %g seconds (created cells)\n************\n", createtime)}
connectstart = startsw()				// Grab start time of cell connection

/***********************************************************************************************
V.	CONNECT THE STIMULATION CELLS TO SOME MODEL CELLS
***********************************************************************************************/
{load_file("./setupfiles/nc_append_functions.hoc")}			// Defines nc_append and nc_appendo, which are needed to create the netcons for connections

strdef stimtype
{stimtype="singlecell"} // spontaneous // grid
{sprint(cmd,"./setupfiles/%s_stimulation.hoc", stimtype)}
{load_file(cmd)}			// Loads in a particular stimulation protocol, including the connections from the artificial cells and their stimulation design

/***********************************************************************************************
VI.	LOOP: (RE)DEFINE NETWORK CONNECTIONS, INITIALIZE AND RUN NETWORK, OUTPUT RESULT FILES
***********************************************************************************************/
	//	INITIALIZE AND RUN NETWORK, OUTPUT RESULT FILES
	proc init() { local dtsav, temp, secsav, secondordersav	// initialize the simulation
		dtsav = dt						// Save desired dt value to reset after temporarily changing dt
		secondordersav = secondorder	// Save desired secondorder value to reset after temporarily changing secondorder

		finitialize(v_init)	// Call finitialize (since we are replacing the default init proc that calls this)
							// finitialize will Call the INITIAL block for all mechanisms and point processes inserted in the sections
							//	and set the initial voltage to v_init for all sections

		t = -500			// Set the start time for (pre) simulation; -500 to prepare network in advance of start at 0
		dt= 10				// Set dt to large value
		secondorder = 0		// Set secondorder to 0 to set the default fully implicit backward euler for numerical integration (see NEURON ref)
			
		temp= cvode.active()
		if (temp!=0) {cvode.active(0)}	// If cvode is on, turn off temporarily to do large fixed step
		// Now, do a large pre run from t = -500 to t = -100 to set the network 'settle' and all components to reach steady state
		while(t<-100) { fadvance() if (flagprint>1) {print t}}	// Integrate all section equations over the interval dt. increment t by dt
																//	and repeat till t at -100
		if (temp!=0) {cvode.active(1)}	// If cvode was on and then turned off, turn it back on now
		
		t = tstart 						// Start time of the simulation
		dt = dtsav						// Reset dt to specified value
		secondorder = secondordersav	// Reset secondorder to specified value
		if (cvode.active()){
			cvode.re_init()				// If cvode is active, initialize the integrator
		} else {
			fcurrent()					// If cvode is not active, make all assigned variables (currents, conductances, etc)
										//	consistent with the values of the states
		}
	}

	proc rrun(){												// Run the network simulation
		pnm.want_all_spikes() 						// Record all spikes of all cells on this machine into the pnm.spikevec (spiketimes) and pnm.idvec (gids)
		pc.set_maxstep(10)							// Set every machine's max step size to minimum delay of all netcons created on pc using pc.gid_connect, but not larger than 10
		stdinit()									// Call the init fcn (which is redefined in this code) and then make other standard calls (to stop watch, etc)
		pc.psolve(tstop)							// Equivalent to calling cvode.solve(tstop), for parallel NEURON, where solve will be broken into steps determined by the result of set_maxstep
		runtime = startsw() - runstart				// Calculate runtime of simulation
		if (pc.id == 0) {printf("****\nTIME SUMMARY for host 0\nset up in %g seconds\ncreated cells in %g seconds\nconnected cells in %g seconds\nran simulation in %g seconds\n************\nThis run is called: %s\n************\n", loadtime, createtime, connecttime, runtime, runname)}
		traceout()	// Write the file of spike times and spiking cells, "spikeraster.dat"
		if (printConMat==1) {tracenet()}	// Write the file of all cell connections (pre and post gids, synapse type, host on which cell exists), "connections.dat"
	}
	
objref pyrcell, inhsyn, myvec, f
strdef tracename, outfile, direx
pyrcell = pc.gid2cell(1)
rnum=0
	//{load_file("./setupfiles/set_loop_traces.hoc")}		// set up recorders
	//{load_file("./setupfiles/write_loop_traces.hoc")}		// print out stuff
	sprint(direx,"mkdir results/%s/traces", runname)
{system(direx)}
forsec pyrcell.all {
	// redefine network connections
	for (pos = .1; pos <= .9 ; pos=pos+.2) {
		secname() inhsyn = new MyExp2Sid(pos)
	
    	inhsyn.tau1 = 1
    	inhsyn.tau2 = 8
    	inhsyn.e = -75
    	inhsyn.sid=(rnum + pos)*10
		nc_appendo(2, pyrcell, 2, 0, 2e-2, 3)  
    	
    	myvec = new Vector(tstop/dt)
    	myvec.record(&pyrcell.soma.v(0.5))
		run()	// Run the network simulation

		sprint(outfile, "results/%s/traces/trace_%s_%g_%g.dat", runname, secname(), rnum, pos)
		f = new File(outfile)
		f.wopen()
		f.printf("t\tv\n")
		for i=0, (tstop-tstart)/dt-1 {
			f.printf("%g\t%g\n", i*dt, myvec.x[i])
		}
		f.close()

	}
	rnum = rnum + 1
}

{pc.runworker()} 	// Everything after this line is executed only by the host node
					// "The master host returns immediately. Worker hosts start an infinite loop of requesting tasks for execution." 
{pc.done()}			// Sends the quit message to the worker processors, which then quit neuron
quit()	// Sends the quit message to the host processor, which then quits neuron
