// An approximation to the LFP generated by the pyramidal cells in the network.
// Computed as the difference in voltage between apical distal and basal dendrites.

func dipole_lfp() { local avglfp, vlfp, ncells, celltype, pci, gid, i, typei localobj cell
    
    for celltype=0, numCellTypes-1 {
        
	if (strcmp(cellType[celltype].cellType_string, "pyramidalcell")==0) {
	    
           vlfp = 0
	   for pcitr(&i, &typei, &gid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
	       ncells = cellType[celltype].cellEndGid - cellType[celltype].cellStartGid
               cell = pc.gid2cell(gid)
               vlfp = vlfp + cell.apical[cell.NumApical-1].v(0.5) - cell.basal[0].v(0.5)
           }
       }
       
   }
   
   // average over all hosts
   avglfp = pc.allreduce(vlfp, 1)/ncells
   
   return avglfp
}

// Compute the lfp for the cells whose voltage is recorded 
obfunc dipole_lfp_traceidx() { local vlfp, gid, i, typei localobj traceidxlist, cell, r, vec
    
    traceidxlist = $o1
    r = new List()
    
    for i=0, traceidxlist.count()-1 {
        
        vlfp = 0
        gid = traceidxlist.o(i)
        cell = pc.gid2cell(gid)
        vlfp = cell.apical[cell.NumApical-1].v(0.5) - cell.basal[0].v(0.5)
        vec = new Vector()
        vec.append(t, gid, vlfp)
        r.append(vec)
       }
       
   }
   
   return r
}

objref lfplist, lfptracelist
lfplist = new List()
lfptracelist = new List()

lfp_dt = 0.5 // sampling interval for LFP


proc sample_lfp() { local avglfp localobj vec, lfptraces
    avglfp = dipole_lfp()
    if (pc.id == 0) {
        vec = new Vector()
        vec.append(t, avglfp)
        lfplist.append(vec.c)
    }
    if (name_declared("traceidxlist")) {
        lfptraces = dipole_lfp_traceidx(traceidxlist)
        lfptracelist.append(lfptraces)
    }
    cvode.event(t + lfp_dt, "sample_lfp()") // execute sample_lfp lfp_dt ms from now
}

