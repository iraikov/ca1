begintemplate ngfcell

// public variables
public  pre_list, connect_pre, append_sections, is_art, is_connected, gid, randi
public soma, bcdendAP1, bcdendAP2, bcdendBAS1, bcdendBAS2
public all, adend, bdend, cdend, ddend, basal_list, apical_list, soma_list, axon_list
public x, y, z, position

public pyramidalcell_list, axoaxoniccell_list, bistratifiedcell_list, cckcell_list
public ivycell_list, ngfcell_list, olmcell_list, pvbasketcell_list, scacell_list
public eccell_list, ca3cell_list, mscell_list

// objects
objref syn, pre_list, templist

// external variables
external numCellTypes, cellType

// create the sections[nsegments]
// if nsegments (the number of segments in each section) is updated,
// you'll have to manually change the bounds on the for loops as well
create soma, bcdendAP1[4], bcdendAP2[4], bcdendBAS1[4], bcdendBAS2[4]

// set the initialization code, which is run whenever a new object
// of this class is instantiated
proc init() {
	gid = $1
	randi = $2
	// cell sections: soma, dendrites, axon
	append_sections() // append all sections to the section list
	connect_sections()// connect soma, dendrites, axon
	size_sections()	// set the size dimensions of each section
	set_nseg()		// set the number of segments in each section
	
	// subcellular mechanisms: channels, pumps, transporters
	mechinit()
	insert_mechs()
	set_biophys()
	define_shape()

	pre_list = new List() // define a list for the presynaptic connections
	define_synapses()
}

objref all, adend, bdend, cdend, ddend // this is also defined later, in a fcn. which place should it be defined?
proc connect_sections() { local i
	connect bcdendAP1[0](0), soma(1)
	connect bcdendAP2[0](0), soma(1)
	connect bcdendBAS1[0](0), soma(0)
	connect bcdendBAS2[0](0), soma(0)
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendAP1[i](0), bcdendAP1[i-1](1)
	}
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendAP2[i](0), bcdendAP2[i-1](1)
	}
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendBAS1[i](0), bcdendBAS1[i-1](1)
	}
	for i=1, 3 { // upper bound is # of segments - 1
	connect bcdendBAS2[i](0), bcdendBAS2[i-1](1)
	}
}

objref basal_list, apical_list, soma_list, axon_list
objref pyramidalcell_list, axoaxoniccell_list, bistratifiedcell_list, cckcell_list
objref ivycell_list, ngfcell_list, olmcell_list, pvbasketcell_list, scacell_list
objref eccell_list, ca3cell_list, mscell_list

proc append_sections() { local i
objref all, basal_list, apical_list, soma_list, axon_list
objref pyramidalcell_list, axoaxoniccell_list, bistratifiedcell_list, cckcell_list
objref ivycell_list, ngfcell_list, olmcell_list, pvbasketcell_list, scacell_list
objref eccell_list, ca3cell_list, mscell_list

	pyramidalcell_list = new SectionList()
	axoaxoniccell_list = new SectionList()
	bistratifiedcell_list = new SectionList()
	cckcell_list = new SectionList()
	ivycell_list = new SectionList()
	ngfcell_list = new SectionList()
	olmcell_list = new SectionList()
	pvbasketcell_list = new SectionList()
	scacell_list = new SectionList()
	eccell_list = new SectionList()
	ca3cell_list = new SectionList()
	mscell_list = new SectionList()
	// Make a list for every section in the cell
	all = new SectionList()	
  basal_list = new SectionList()
  apical_list = new SectionList()
  soma_list = new SectionList()
  axon_list = new SectionList()
  
		soma all.append()
		soma soma_list.append()
		for i=0, 3 {bcdendAP1 [i] all.append()
					bcdendAP1 [i] apical_list.append()}
		for i=0, 3 {bcdendAP2 [i] all.append()
					bcdendAP2 [i] apical_list.append()}
		for i=0, 3 {bcdendBAS1 [i] all.append()
					bcdendBAS1 [i] basal_list.append()}
		for i=0, 3 {bcdendBAS2 [i] all.append()
					bcdendBAS2 [i] basal_list.append()}

	// Make lists of dendrite sections that
	//  are all the same relative distance
	//  from the soma (useful when adding ion channels)
	// The code in this section will have to be customized
	//  depending on how detailed (and different) the sections
	//  are for each main dendrite
	adend  = new SectionList()	
		bcdendAP1 [0] adend.append()
		bcdendAP2 [0] adend.append()
		bcdendBAS1 [0] adend.append()
		bcdendBAS2 [0] adend.append()

	bdend  = new SectionList()
		bcdendAP1 [1] bdend.append()
		bcdendAP2 [1] bdend.append()
		bcdendBAS1 [1] bdend.append()
		bcdendBAS2 [1] bdend.append()

	cdend  = new SectionList()
		bcdendAP1 [2] cdend.append()
		bcdendAP2 [2] cdend.append()
		bcdendBAS1 [2] cdend.append()
		bcdendBAS2 [2] cdend.append()

	ddend  = new SectionList()
		bcdendAP1 [3] ddend.append()
		bcdendAP2 [3] ddend.append()
		bcdendBAS1 [3] ddend.append()
		bcdendBAS2 [3] ddend.append()

// cell lists
		for i=0, 1 {
			bcdendAP1 [i] scacell_list.append()
			bcdendAP2 [i] scacell_list.append()
		}
		for i=0, 3 {
			bcdendBAS1 [i] scacell_list.append()
			bcdendBAS2 [i] scacell_list.append()
		}

		for i=0, 3 {
			bcdendBAS1 [i] pyramidalcell_list.append()
			bcdendBAS2 [i] pyramidalcell_list.append()
		}

		for i=2, 3 {
			bcdendAP1 [i] eccell_list.append()
			bcdendAP2 [i] eccell_list.append()
		}

		for i=0, 1 {
			bcdendAP1 [i] ca3cell_list.append()
			bcdendAP2 [i] ca3cell_list.append()
		}
		
		forsec soma_list {pvbasketcell_list.append()}
		
		forsec soma_list {cckcell_list.append()}

		for i=2, 3 {
			bcdendAP1 [i] ngfcell_list.append()
			bcdendAP2 [i] ngfcell_list.append()
		}

		for i=0, 3 {
			bcdendBAS1 [i] olmcell_list.append()
			bcdendBAS2 [i] olmcell_list.append()
		}

		for i=0, 1 {
			bcdendAP1 [i] ivycell_list.append()
			bcdendAP2 [i] ivycell_list.append()
		}
		for i=0, 3 {
			bcdendBAS1 [i] ivycell_list.append()
			bcdendBAS2 [i] ivycell_list.append()
		}

		for i=0, 1 {
			bcdendAP1 [i] bistratifiedcell_list.append()
			bcdendAP2 [i] bistratifiedcell_list.append()
		}
		for i=0, 3 {
			bcdendBAS1 [i] bistratifiedcell_list.append()
			bcdendBAS2 [i] bistratifiedcell_list.append()
		}
}

proc size_sections() { local i
	soma {L=20 diam=15}
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendAP1 [i] {L=50 diam=4-i}
	}	
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendAP2 [i] {L=50 diam=4-i}
	}	
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendBAS1 [i] {L=25 diam=4-i}
	}	
	for i=0, 3 { // upper bound is # of segments - 1
		bcdendBAS2 [i] {L=25 diam=4-i}
	}
}

proc set_nseg() {
  forsec all { nseg = 1 }
}

proc mechinit() {
	gNasoma=3.7860265 
	gNadend=0.25918894  
	gKvA=5.2203905e-06
	kdrf=0.15514516
	kdrfdend = 0.0021817289
	gleak=8.470825e-05
	gCavL=0.056108352
	gCavN=0.00058169587
	gKvCaB=1.0235317e-06 
	gKCaS=4.5152237e-07  
	myRa = 14 //75
	CM = 1.8 //1.8
	offset1=20
	offset2=20
	offset3=13.5816 
	offset4=13.35371
	slope1=0.68266
	slope2=0.56966
	slope3=1.18592
	slope4=49.4896
	offset5=9
	offset6=9
	slope5=.07
	slope6=.264
}
	
proc insert_mechs() {
	forsec all {
		insert iconc_CaZ
			catau_iconc_CaZ = 10
			caiinf_iconc_CaZ = 5.e-6
		insert ch_KvAngf
	gmax_ch_KvAngf = gKvA
		insert ch_CavN  // HAV-N- Ca channel
	gmax_ch_CavN =   gCavN
		insert ch_CavL 
	gmax_ch_CavL=gCavL
		insert ch_KCaS
	gmax_ch_KCaS=gKCaS
		insert ch_KvCaB
	gmax_ch_KvCaB =gKvCaB
	cm=CM
	}

	soma {
	insert ch_Navngf
	gmax_ch_Navngf=gNasoma //0.10*gna_scale
	offset1_ch_Navngf=offset1
	offset2_ch_Navngf=offset2
	offset3_ch_Navngf=offset3
	offset4_ch_Navngf=offset4
	slope1_ch_Navngf=slope1
	slope2_ch_Navngf=slope2
	slope3_ch_Navngf=slope3
	slope4_ch_Navngf=slope4
	ena = 55 
		insert ch_Kdrfastngf
	gmax_ch_Kdrfastngf=kdrf 
	offset5_ch_Kdrfastngf=offset5 
	offset6_ch_Kdrfastngf=offset6 
	slope6_ch_Kdrfastngf=slope6 
	slope5_ch_Kdrfastngf=slope5	
//		insert ch_Kdrslow
//	gmax_ch_Kdrslow=kdrf 
	
	insert ch_leak
	gmax_ch_leak = gleak
	} 

	forsec adend {
	insert ch_Navngf
	gmax_ch_Navngf=gNadend //0.08*gna_scale
	offset1_ch_Navngf=offset1
	offset2_ch_Navngf=offset2
	offset3_ch_Navngf=offset3
	offset4_ch_Navngf=offset4
	slope1_ch_Navngf=slope1
	slope2_ch_Navngf=slope2
	slope3_ch_Navngf=slope3
	slope4_ch_Navngf=slope4
	ena = 55 
		insert ch_Kdrfastngf
	gmax_ch_Kdrfastngf=kdrfdend //.007
	offset5_ch_Kdrfastngf=offset5 
	offset6_ch_Kdrfastngf=offset6 
	slope6_ch_Kdrfastngf=slope6 
	slope5_ch_Kdrfastngf=slope5	
//		insert ch_Kdrslow
//	gmax_ch_Kdrslow=kdrf 
	
	insert ch_leak
	gmax_ch_leak = gleak
	}	
		
	forsec bdend {
	insert ch_Navngf
	gmax_ch_Navngf=gNadend //0.08*gna_scale
	offset1_ch_Navngf=offset1
	offset2_ch_Navngf=offset2
	offset3_ch_Navngf=offset3
	offset4_ch_Navngf=offset4
	slope1_ch_Navngf=slope1
	slope2_ch_Navngf=slope2
	slope3_ch_Navngf=slope3
	slope4_ch_Navngf=slope4
	ena = 55 
		insert ch_Kdrfastngf
	gmax_ch_Kdrfastngf=kdrfdend //.007
	offset5_ch_Kdrfastngf=offset5 
	offset6_ch_Kdrfastngf=offset6 
	slope6_ch_Kdrfastngf=slope6 
	slope5_ch_Kdrfastngf=slope5	
//		insert ch_Kdrslow
//	gmax_ch_Kdrslow=kdrf 
	
	insert ch_leak
	gmax_ch_leak = gleak
	}
		
	forsec cdend {
	insert ch_leak
	gmax_ch_leak = gleak
	}

	forsec ddend {
	insert ch_leak
	gmax_ch_leak = gleak
	}
}

proc set_biophys() {
	forsec all {Ra=myRa}
	forsec all {ek=-90  eca=130
		 e_ch_leak =-60
	cao_iconc_CaZ=2 
		//cao_ccanl=2 
		}  // make catau slower70e-3 	cao=2 cai=50.e-6 
}

	proc connect_pre() {  // $o1 target point process, $o2 returned NetCon
	soma $o2 = new NetCon (&v(1), $o1)
			$o2.threshold = -10 //except for bcell to bcell, which is -10???

	}

	func is_art()  { return 0 }

proc position(){ local i
		forall {
		for i = 0, n3d()-1 {
			pt3dchange(i, $1-x+x3d(i), $2-y+y3d(i), $3-z+z3d(i), diam3d(i))
		}
}
	x = $1  y = $2  z = $3	
}		

objref syn  
proc define_synapses() {local i localobj f2, f3

}		
endtemplate ngfcell
