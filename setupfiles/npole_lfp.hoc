/************************************************************
'ca1' model code repository
Written by Ivan Raikov, ivan.g.raikov@gmail.com and Marianne
Bezaire, marianne.bezaire@gmail.com, www.mariannebezaire.com
In the lab of Ivan Soltesz, www.ivansolteszlab.org
Latest versions of this code are available online at:
ModelDB: 
Open Source Brain: http://www.opensourcebrain.org/projects/nc_ca1

This file computes an approximation to the LFP generated by the
pyramidal cells in the network, based on the formula by Schomburg et
al., J Neurosci 2012.

The approximate LFP is calculated as the sum of current contributions
of all compartments, scaled by the distances to the recording
electrode and extracellular medium resistivity.  The time resolution
of the LFP calculation may be lower than that of the simulation by
setting lfp_dt in this file.
************************************************************/

objref lfplist, lfp_ids, lfp_types, lfpkmatrix, rlfp

lfplist    = new List()
lfpkmatrix = new Matrix()
lfp_ids    = new Vector()
lfp_types  = new Vector()
rlfp       = new Random()

rlfp.uniform(0,1)

func arcsin () { local x, xx, result
    x = $1
    xx = 1.0 - x*x
    
    if (xx < 0) {
       result = atan2(x, 0)
    } else {
       result = atan2(x, sqrt(xx))
    }

    return result
}

func npole_pos_lfp() { local avglfp, vlfp, celltype, pci, gid, i, j, ex, ey, ez, typei, MaxEDist localobj cell
 	// Calculate the average LFP of select pyramidal cells in the network,
	//  only including pyramidal cells whose somata are within MaxEDist
	//  microns of the (x,y,z) location passed into this function as
	//  arguments: $1 = x, $2 = y, $3 = z in microns
	
	MaxEDist = $1 // microns
        ex = $2
        ey = $3
        ez = $4
        
	sumcell = 0
	vlfp = 0 // Initialize the LFP variable
        
        for i=0, lfp_ids.size()-1 { // Iterate over all cells chosen for the LFP computation
            
            gid  = lfp_ids.x[i]
	    cell = pc.gid2cell(gid)
	    
            j = 0
            forsec cell.all { 
                if (ismembrane("extracellular")) {
		    for (x,0) { 
                        vlfp = vlfp + (i_membrane(x) * lfpkmatrix.x[i][j])
                    }
                    j = j + 1
                }
            }
	}

	// Ensure all processors have completed their calculation before proceeding.
	pc.barrier()
        
        avglfp = pc.allreduce(vlfp, 1)
        
        return avglfp
    }
    
// Distance from a point to a line in 3D
// The point is defined by x0, y0, z0
// The line is defined by starting point x1, y1, z1 and ending point x2, y2, z2
proc linedist () { local x0, x1, x2, y0, y1, y2, z0, z1, z2, la, lb, lc, s, a, r, h, abc localobj res
    
    res = $o1
    
    x0 = $2
    y0 = $3
    z0 = $4
    // line starting point
    x1 = $5
    y1 = $6
    z1 = $7
    // line ending point
    x2 = $8
    y2 = $9
    z2 = $10
    
    // Calculates the area of the triangle formed by the three points
    // using Heron's formula
    
    // Lengths of triangle sides
    la = sqrt((x1-x0)*(x1-x0) + (y1-y0)*(y1-y0) + (z1-z0)*(z1-z0))
    lb = sqrt((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) + (z2-z1)*(z2-z1))
    lc = sqrt((x2-x0)*(x2-x0) + (y2-y0)*(y2-y0) + (z2-z0)*(z2-z0))
    
    // Semiperimeter of triangle
    s = (la + lb + lc) / 2
    
    // Area of triangle
    a = sqrt(s * (s - la) * (s - lb) * (s - lc))
    
    // Perpendicular distance from point to line
    r = (a*2) / lb
    
    // Angle between point and starting point of line
    abc = arcsin(r / la)
    
    // Longitudinal distance from point to starting point of line
    h = la * cos(abc)

    res.x[0] = r
    res.x[1] = h
}


proc sample_npole_lfp() { local i, j, k, m, n, r, h, s, avglfp, typei, gid, celltype, ex, ey, ez, lfptype localobj cell, dists, vec, lst
    
    rho = 333.0 // extracellular resistivity, [ohm cm]
    fdst = 0.2 // percent of distant cells to include in the computation
    
    ex = mypoint.x[0]
    ey = mypoint.x[1]
    ez = mypoint.x[2]
    
    // At t=0, calculate distances from recording electrode to all
    // compartments of all pyramidal cells, calculate scaling
    // coefficients for the LFP calculation, and save them in
    // lfpkmatrix.
    
    if (t == 0) {
        printf ("host %d: entering sample_npole_lfp\n", pc.id)
        
        // Vector for storing longitudinal and perpendicular distances
        // between recording electrode and compartments
        dists = new Vector(2)
        
        // This loop determines which cells will be used for the LFP computation and the sizes of their compartments
        for celltype=0, numCellTypes-1 { // Iterate over all cell types
	    if (strcmp(cellType[celltype].cellType_string, "pyramidalcell")==0) {	// Choosing pyramidal cells	
                m = 0
                n = 0
		for pcitr(&i, &typei, &gid, cellType[celltype].cellStartGid, cellType[celltype].cellEndGid) {
                    cell = pc.gid2cell(gid)
		    // Relative to the recording electrode position
		    if (sqrt((cell.x-ex)*(cell.x-ex) + (cell.y-ey)*(cell.y-ey) + (cell.z-ez)*(cell.z-ez))<MaxEDist) {
                        lfptype = 1 // proximal cell
                    } else if (rlfp.repick() < fdst) {
                        lfptype = 2 // distal cell -- include only fdst fraction of total
                    } else {
                        lfptype = 0
                    }
                    if (lfptype > 0) {
                        printf ("host %d: sample_npole_lfp: adding %d\n", pc.id, gid)
                        lfp_ids.append(gid)
                        lfp_types.append(lfptype)
                        m = m+1
                        if (n == 0) {
                            forsec cell.all { 
                                if (ismembrane("extracellular")) {
                                    n = n + 1
                                }
                            }
                        }
                    }
                    
                }
                if (m > 0) {
  	          lfpkmatrix = new Matrix(m+1,n+1)
		  printf ("host %d: npole_lfp: lfpkmatrix.nrow = %d lfpkmatrix.ncol = %d\n", pc.id, lfpkmatrix.nrow, lfpkmatrix.ncol)
                }
                break
	    }
        }
        
        for i=0, lfp_ids.size()-1 { // Iterates over all cells chosen for the LFP computation
            
            gid = lfp_ids.x[i]
	    cell = pc.gid2cell(gid)
	    
            // Iterates over each compartment of the cell
            j = 0
            forsec cell.all { 
                // L is compartment length 
                // r is the perpendicular distance from the electrode to a line through the compartment
                // h is longitudinal distance along this line from the electrode to one end of the compartment
                // s = l + h is longitudinal distance to the other end of the compartment
                linedist (dists,ex,ey,ez,x3d(0),y3d(0),z3d(0),x3d(n3d()-1),y3d(n3d()-1),z3d(n3d()-1))
                r = dists.x[0]
                h = dists.x[1]
                s = L + h
                k = 0.0001 * area(0.5) * (rho / (4 * PI * L)) * abs(log((sqrt(h*h + r*r) - h) / (sqrt(s*s + r*r) - s)))
                // Distal cell
                if (lfp_types.x[i] == 2) {
 		    k = (1.0/fdst)*k
                } 
                printf ("host %d: npole_lfp: gid = %d i = %d j = %d r = %g h = %g k = %g\n", pc.id, gid, i, j, r, h, k)
 		lfpkmatrix.x[i][j] = k
                j = j + 1
            }
	}
    }
    
    // Execute this code regularly throughout the simulation
    //  to add datapoints to all the LFP recordings (average
    //  and per-cell).
    
    // Compute LFP across a subset of cells within a certain distance from the recording electrode:
    avglfp = npole_pos_lfp(MaxEDist,ex,ey,ez) // x, y, z position of electrode in microns
    
    if (pc.id == 0) {
        
        vec = new Vector()
        // For this time step, create a vector with entries of time and average LFP
	vec.append(t, avglfp)			
        // Append the vector for this time step to the list
	lfplist.append(vec.c)			
    }
    
    
    // Add another event to the event queue, to 
    // execute sample_npole_lfp again, lfp_dt ms from now
    cvode.event(t + lfp_dt, "sample_npole_lfp()")		
}